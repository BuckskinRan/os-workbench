# 1. os-workbench
lpr learning OS in NJU

<!-- TOC -->

- [1. os-workbench](#1-os-workbench)
    - [1.1. MiniLab](#11-minilab)
        - [1.1.1. M1](#111-m1)
        - [1.1.2. M2](#112-m2)
        - [1.1.3. M3](#113-m3)
    - [1.2. OSLab](#12-oslab)
        - [1.2.1. L0](#121-l0)

<!-- /TOC -->
## 1.1. MiniLab
### 1.1.1. M1
- 打印时候建立树后一次深度优先搜索即可，-n对程序的影响要高于-p，-p只影响打印格式，-n影响排序方式，一开始没有理清楚逻辑带来了一点点困惑
- 感谢某王姓同学的建议，需要考虑父节点PID反而小于字节点PID的情形
- -V的输出使用stderr，且优点度最高

### 1.1.2. M2
`现阶段感想，发现错误随时更改`

对于单独的某个进程而言，估计`yield()`在单个协程的运行看来实际效果如下：
```
+-----------------------+
| execute nomarly   |
+-----------------------+
         |
         | 
         +->+------------+
                |call yield  |
               +------------+
                         |
               +-----------+
               | set_jmp |
              +------------+
                         |
          +-------------------+
          |do other thing |
          +-------------------+
                         |
            +--------------+
            | come back | // 在这种情况下，别的协程顺利调用了这个协程的恢复部分，然后由于走之前又一次set_jmp, 这次用long_jmp跳回来，就可以区分了
            +-----------+
                        |
        +--------+
        |
+----------------------+
|continue execute|   
+----------------------+                  

```
OK, 那么现在的问题就是应该怎么恢复寄存器和堆栈现场，考虑这两个的先后顺序了，如果要先恢复寄存器，那么PC就会回到当初程序`set_jmp`的位置，这个时候似乎就会直接继续进行下一条指令了（）


`stack_switch_call`
```
   before                              switch stack                  start of func
+---------+                            +---------+                    +---------+          
|                | <- old esp         |              |                    |         |
+---------+                              +---------+                    +---------+
|         |                    |         |                    |         |
+---------+                    +---------+                    +---------+
    ...                            ...                            ...
+---------+                    +---------+                    +---------+
|         | <- old ebp         |         | <- old ebp         |         |
+---------+                    +---------+                    +---------+
    ...                            ...                            ...
+---------+                    +---------+                    +---------+
|         | <- co              |         | <- co              |         | <- co
+---------+                    +---------+                    +---------+
    ...                            ...                            ...
+---------+                    +---------+                    +---------+
|co->stack|                    |co->stack|                    |co->stack|
+---------+                    +---------+                    +---------+
    ...                            ...                            ...
+---------+                    +---------+                    +---------+
|st bottom|                    |st bottom|                    | old ebp | <- new esp, new ebp
+---------+                    +---------+                    +---------+
|         | <- co+1            |         | <- new esp, co+1   |         | <- new esp, co+1
+---------+                    +---------+                    +---------+
```

现在遇到了`vsprintf`的问题…估计是对齐的问题吧。还得慢慢调试…

更新M2思路

运用包装函数之后，每一个协程的启动都==一定==是通过`调用stack_switch_call`$\rightarrow$`进入对应的包装函数`正因如此，我们也就可以直接得到一个结论——==所有==包装函数都一定不能通过`return`返回，换而言之，最后函数的结尾对应的即是到达`co_wrapper`函数返回值，然后状态标记为停机，通过`yield`主动调度，从调度函数变成了调度包装函数。


### 1.1.3. M3
首先强烈推荐几个需要看的网页，[网页链接](https://blog.csdn.net/strugglelg/article/details/8954238)。这里面可以看到如何提取Linux获得系统的环境变量与所需名字的环境变量。值得一提的是，在提取时间时是我发现貌似系统立马的信号量也会有时间消耗？我是按行从管道中提取文字的，所以只需要提取开头第一个小写单词（必须紧接着一个括号，否则有溢出的风险，小写单词可以保证是系统调用而非信号量）和末尾第一对尖括号包裹着的字符型小数，然后使用`strtod`将其转为浮点数即可。

几个值得关注的小东西：`strtod`、`CLOCKS_PER_SEC`、`extern environ`、`strtok`

还有几个小地方是：
- 每秒打印一次考虑不周在总时间小于一秒的情况下会直接出问题。（easy一开始就是这么错的）。
- 父进程要在一开始自觉关闭管道的写入权限，否则子进程关闭后父进程的读会进入阻塞状态而不能正常结束
- 关于strace的路径，提取到PATH的值后用":"进行分割，然后一个一个与"/strace"组合尝试执行，不能执行的返回值是-1，抓住这个特征就好了。
## 1.2. OSLab

### 1.2.1. L0
- 写2048的时候没有注意到色号不符合VGA的格式，搞得程序老是崩溃，自己还没有找到问题
- 绘制方块参考老师splash里的方式即可，splash里的方块确实小了点，可以调整绘制时候x，y值（比如使用x / 3,y / 3就可以让边长变成原来打三倍），不建议调整SIDE，调整SIDE后出现过一些奇奇怪怪的问题，与同学讨论后没有结果